<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>BeamAdapter: /home/alex/Documents/Dev/Sofa/applications/plugins/BeamAdapter/AdaptiveBeamMapping.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">BeamAdapter
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_adaptive_beam_mapping_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">/home/alex/Documents/Dev/Sofa/applications/plugins/BeamAdapter/AdaptiveBeamMapping.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/******************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">*       SOFA, Simulation Open-Framework Architecture, version 1.0 beta 4      *</span>
<a name="l00003"></a>00003 <span class="comment">*                (c) 2006-2009 MGH, INRIA, USTL, UJF, CNRS                    *</span>
<a name="l00004"></a>00004 <span class="comment">*                                                                             *</span>
<a name="l00005"></a>00005 <span class="comment">* This library is free software; you can redistribute it and/or modify it     *</span>
<a name="l00006"></a>00006 <span class="comment">* under the terms of the GNU Lesser General Public License as published by    *</span>
<a name="l00007"></a>00007 <span class="comment">* the Free Software Foundation; either version 2.1 of the License, or (at     *</span>
<a name="l00008"></a>00008 <span class="comment">* your option) any later version.                                             *</span>
<a name="l00009"></a>00009 <span class="comment">*                                                                             *</span>
<a name="l00010"></a>00010 <span class="comment">* This library is distributed in the hope that it will be useful, but WITHOUT *</span>
<a name="l00011"></a>00011 <span class="comment">* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *</span>
<a name="l00012"></a>00012 <span class="comment">* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License *</span>
<a name="l00013"></a>00013 <span class="comment">* for more details.                                                           *</span>
<a name="l00014"></a>00014 <span class="comment">*                                                                             *</span>
<a name="l00015"></a>00015 <span class="comment">* You should have received a copy of the GNU Lesser General Public License    *</span>
<a name="l00016"></a>00016 <span class="comment">* along with this library; if not, write to the Free Software Foundation,     *</span>
<a name="l00017"></a>00017 <span class="comment">* Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA.          *</span>
<a name="l00018"></a>00018 <span class="comment">*******************************************************************************</span>
<a name="l00019"></a>00019 <span class="comment">*                               SOFA :: Modules                               *</span>
<a name="l00020"></a>00020 <span class="comment">*                                                                             *</span>
<a name="l00021"></a>00021 <span class="comment">* Authors: The SOFA Team and external contributors (see Authors.txt)          *</span>
<a name="l00022"></a>00022 <span class="comment">*                                                                             *</span>
<a name="l00023"></a>00023 <span class="comment">* Contact information: contact@sofa-framework.org                             *</span>
<a name="l00024"></a>00024 <span class="comment">******************************************************************************/</span>
<a name="l00025"></a>00025 <span class="comment">//</span>
<a name="l00026"></a>00026 <span class="comment">// C++ Implementation : AdaptiveBeamMapping</span>
<a name="l00027"></a>00027 <span class="comment">//</span>
<a name="l00028"></a>00028 <span class="comment">// Description:</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">//</span>
<a name="l00031"></a>00031 <span class="comment">// Author: Christian Duriez, INRIA</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">// Copyright: See COPYING file that comes with this distribution</span>
<a name="l00034"></a>00034 <span class="comment">//</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef SOFA_COMPONENT_MAPPING_ADAPTIVEBEAMMAPPING_H</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define SOFA_COMPONENT_MAPPING_ADAPTIVEBEAMMAPPING_H</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;initBeamAdapter.h&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;BeamInterpolation.h&quot;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;AdaptiveBeamController.h&quot;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;sofa/core/Mapping.h&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;sofa/core/behavior/MechanicalState.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;sofa/defaulttype/RigidTypes.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;sofa/helper/vector.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;sofa/defaulttype/Vec.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &lt;sofa/defaulttype/Mat.h&gt;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &lt;sofa/component/topology/EdgeSetTopologyModifier.h&gt;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &lt;sofa/core/topology/BaseMeshTopology.h&gt;</span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &lt;sofa/core/objectmodel/Event.h&gt;</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="keyword">using namespace </span>sofa::component::fem;
<a name="l00054"></a>00054 <span class="keyword">using namespace </span>sofa::core::objectmodel;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">namespace </span>sofa
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">namespace </span>component
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061    <span class="comment">/* namespace topology</span>
<a name="l00062"></a>00062 <span class="comment">    {</span>
<a name="l00063"></a>00063 <span class="comment">        template &lt;class T&gt;</span>
<a name="l00064"></a>00064 <span class="comment">        class EdgeSetGeometryAlgorithms;</span>
<a name="l00065"></a>00065 <span class="comment"></span>
<a name="l00066"></a>00066 <span class="comment">        class EdgeSetTopologyModifier;</span>
<a name="l00067"></a>00067 <span class="comment">    }</span>
<a name="l00068"></a>00068 <span class="comment">    */</span>
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="keyword">namespace </span>mapping
<a name="l00071"></a>00071 {
<a name="l00072"></a>00072 
<a name="l00077"></a>00077 <span class="keyword">template</span> &lt;<span class="keyword">class</span> TIn, <span class="keyword">class</span> TOut&gt;
<a name="l00078"></a><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html">00078</a> <span class="keyword">class </span><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html" title="AdaptiveBeamMapping Class.">AdaptiveBeamMapping</a> : <span class="keyword">public</span> core::Mapping&lt;TIn, TOut&gt;
<a name="l00079"></a>00079 {
<a name="l00080"></a>00080 <span class="keyword">public</span>:
<a name="l00081"></a>00081         SOFA_CLASS(SOFA_TEMPLATE2(<a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html" title="AdaptiveBeamMapping Class.">AdaptiveBeamMapping</a>,TIn,TOut), SOFA_TEMPLATE2(core::Mapping,TIn,TOut));
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <span class="keyword">typedef</span> core::Mapping&lt;TIn, TOut&gt; Inherit;
<a name="l00084"></a>00084     <span class="keyword">typedef</span> TIn In;
<a name="l00085"></a>00085     <span class="keyword">typedef</span> TOut Out;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087         <span class="keyword">typedef</span> <span class="keyword">typename</span> Out::Coord::value_type Real          ;
<a name="l00088"></a>00088         <span class="keyword">typedef</span> <span class="keyword">typename</span> Out::Coord             Coord         ;
<a name="l00089"></a>00089         <span class="keyword">typedef</span> <span class="keyword">typename</span> Out::Deriv             Deriv         ;
<a name="l00090"></a>00090         <span class="keyword">typedef</span> <span class="keyword">typename</span> Out::VecCoord          VecCoord      ;
<a name="l00091"></a>00091         <span class="keyword">typedef</span> <span class="keyword">typename</span> Out::VecDeriv          VecDeriv      ;
<a name="l00092"></a>00092     <span class="keyword">typedef</span> <span class="keyword">typename</span> Out::MatrixDeriv       OutMatrixDeriv;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="keyword">typedef</span> <span class="keyword">typename</span> In::Coord::value_type  InReal       ;
<a name="l00095"></a>00095         <span class="keyword">typedef</span> <span class="keyword">typename</span> In::Deriv              InDeriv      ;
<a name="l00096"></a>00096         <span class="keyword">typedef</span> <span class="keyword">typename</span> In::VecCoord           InVecCoord   ;
<a name="l00097"></a>00097         <span class="keyword">typedef</span> <span class="keyword">typename</span> In::VecDeriv           InVecDeriv   ;
<a name="l00098"></a>00098     <span class="keyword">typedef</span> <span class="keyword">typename</span> In::MatrixDeriv        InMatrixDeriv;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     <span class="keyword">typedef</span> helper::vector&lt;unsigned int&gt;                                         VecIndex    ;
<a name="l00101"></a>00101     <span class="keyword">typedef</span> sofa::core::topology::BaseMeshTopology::EdgeID                       ElementID   ;
<a name="l00102"></a>00102     <span class="keyword">typedef</span> sofa::helper::vector&lt;sofa::core::topology::BaseMeshTopology::Edge&gt;   VecEdges    ;
<a name="l00103"></a>00103     <span class="keyword">typedef</span> sofa::helper::vector&lt;sofa::core::topology::BaseMeshTopology::EdgeID&gt; VecElementID;
<a name="l00104"></a>00104 
<a name="l00105"></a>00105     <span class="keyword">typedef</span> <span class="keyword">typename</span> sofa::defaulttype::SolidTypes&lt;InReal&gt;::Transform      Transform       ;
<a name="l00106"></a>00106     <span class="keyword">typedef</span> std::pair&lt;int, Transform&gt;                                      IndexedTransform;
<a name="l00107"></a>00107     <span class="keyword">typedef</span> <span class="keyword">typename</span> sofa::defaulttype::SolidTypes&lt; InReal&gt;::SpatialVector SpatialVector   ;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="keyword">typedef</span> sofa::defaulttype::Vec&lt;3, Real&gt;   Vec3;
<a name="l00110"></a>00110     <span class="keyword">typedef</span> sofa::defaulttype::Vec&lt;6, Real&gt;   Vec6;
<a name="l00111"></a>00111     <span class="keyword">typedef</span> sofa::defaulttype::Mat&lt;3,12,Real&gt; Mat3x12;
<a name="l00112"></a>00112     <span class="keyword">typedef</span> sofa::defaulttype::Mat&lt;12,3,Real&gt; Mat12x3;
<a name="l00113"></a>00113     <span class="keyword">typedef</span> sofa::defaulttype::Mat&lt;6,12,Real&gt; Mat6x12;
<a name="l00114"></a>00114     <span class="keyword">typedef</span> sofa::defaulttype::Mat&lt;12,6,Real&gt; Mat12x6;
<a name="l00115"></a>00115     <span class="keyword">typedef</span> <a class="code" href="classsofa_1_1component_1_1fem_1_1_beam_interpolation.html">sofa::component::fem::BeamInterpolation&lt; TIn &gt;</a> <a class="code" href="classsofa_1_1component_1_1fem_1_1_beam_interpolation.html">BInterpolation</a>;
<a name="l00116"></a>00116 
<a name="l00117"></a>00117     <span class="keyword">typedef</span> std::pair&lt;unsigned int, Vec3&gt; BeamIdAndBaryCoord;
<a name="l00118"></a><a class="code" href="structsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping_1_1_pos_point_definition.html">00118</a>     <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00119"></a>00119     {
<a name="l00120"></a>00120        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> beamId;
<a name="l00121"></a>00121        <span class="comment">//A bary point has 3 components</span>
<a name="l00122"></a>00122        <span class="comment">// The first denote the curvilinear coordinate</span>
<a name="l00123"></a>00123        <span class="comment">// The two followings denote the planar coordinate on the perpendicular cross section on the curve</span>
<a name="l00124"></a>00124        Vec3 baryPoint;
<a name="l00125"></a>00125     } <a class="code" href="structsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping_1_1_pos_point_definition.html">PosPointDefinition</a>;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="keyword">public</span>:
<a name="l00129"></a><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#a630ccdc1b760d0fe8ef99cb70fcbba9e">00129</a>     Data&lt;bool&gt; <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#a630ccdc1b760d0fe8ef99cb70fcbba9e">useCurvAbs</a>;                                                      
<a name="l00130"></a><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#a3054bd5cf55b87ec2a909c376b6deb03">00130</a>     Data&lt; sofa::helper::vector&lt; Vec3 &gt; &gt; <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#a3054bd5cf55b87ec2a909c376b6deb03">points</a>;        
<a name="l00131"></a><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#aeb4f04b72de9519537f59c776dbe338f">00131</a>     Data&lt; double &gt; <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#aeb4f04b72de9519537f59c776dbe338f">proximity</a>;                                           
<a name="l00132"></a><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#aedc69a6db0ba83d1a9cffa14080a048c">00132</a>     Data&lt;bool&gt; <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#aedc69a6db0ba83d1a9cffa14080a048c">contactDuplicate</a>;                                        
<a name="l00133"></a><a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#ab2827dd910b2d99edc4c023bb3d1f28f">00133</a>     Data&lt;std::string&gt; <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html#ab2827dd910b2d99edc4c023bb3d1f28f">nameOfInputMap</a>;                           
<a name="l00134"></a>00134     SingleLink&lt;AdaptiveBeamMapping&lt;TIn, TOut&gt;, <a class="code" href="classsofa_1_1component_1_1fem_1_1_beam_interpolation.html">BInterpolation</a>, BaseLink::FLAG_STOREPATH|BaseLink::FLAG_STRONGLINK&gt; m_adaptativebeamInterpolation;
<a name="l00135"></a>00135         
<a name="l00136"></a>00136     <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html" title="AdaptiveBeamMapping Class.">AdaptiveBeamMapping</a>()
<a name="l00137"></a>00137         : Inherit()
<a name="l00138"></a>00138     , useCurvAbs(initData(&amp;useCurvAbs,true,<span class="stringliteral">&quot;useCurvAbs&quot;</span>,<span class="stringliteral">&quot;true if the curvilinear abscissa of the points remains the same during the simulation if not the curvilinear abscissa moves with adaptivity and the num of segment per beam is always the same&quot;</span>))
<a name="l00139"></a>00139     , points(initData(&amp;points, <span class="stringliteral">&quot;points&quot;</span>, <span class="stringliteral">&quot;defines the mapped points along the beam axis (in beam frame local coordinates)&quot;</span>))
<a name="l00140"></a>00140     , proximity(initData(&amp;proximity, 0.0, <span class="stringliteral">&quot;proximity&quot;</span>, <span class="stringliteral">&quot;if positive, the mapping is modified for the constraints to take into account the lever created by the proximity&quot;</span>))
<a name="l00141"></a>00141     , contactDuplicate(initData(&amp;contactDuplicate,false,<span class="stringliteral">&quot;contactDuplicate&quot;</span>,<span class="stringliteral">&quot;if true, this mapping is a copy of an input mapping and is used to gather contact points (ContinuousFrictionContact Response)&quot;</span>))
<a name="l00142"></a>00142     , nameOfInputMap(initData(&amp;nameOfInputMap,<span class="stringliteral">&quot;nameOfInputMap&quot;</span>, <span class="stringliteral">&quot;if contactDuplicate==true, it provides the name of the input mapping&quot;</span>))
<a name="l00143"></a>00143     , m_adaptativebeamInterpolation(initLink(<span class="stringliteral">&quot;interpolation&quot;</span>, <span class="stringliteral">&quot;Path to the Interpolation component on scene&quot;</span>))
<a name="l00144"></a>00144     , m_inputMapping(NULL)
<a name="l00145"></a>00145     , isSubMapping(false)
<a name="l00146"></a>00146     , isBarycentricMapping(false)
<a name="l00147"></a>00147     {
<a name="l00148"></a>00148         }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     <a class="code" href="classsofa_1_1component_1_1mapping_1_1_adaptive_beam_mapping.html" title="AdaptiveBeamMapping Class.">AdaptiveBeamMapping</a>(core::State&lt; In &gt;* from, core::State&lt; Out &gt;* to,<a class="code" href="classsofa_1_1component_1_1fem_1_1_beam_interpolation.html">BeamInterpolation&lt; TIn &gt;</a>* _interpolation=NULL,<span class="keywordtype">bool</span> _isSubMapping=<span class="keyword">false</span>)
<a name="l00151"></a>00151         : Inherit(from, to)
<a name="l00152"></a>00152     , useCurvAbs(initData(&amp;useCurvAbs,true,<span class="stringliteral">&quot;useCurvAbs&quot;</span>,<span class="stringliteral">&quot;true if the curvilinear abscissa of the points remains the same during the simulation if not the curvilinear abscissa moves with adaptivity and the num of segment per beam is always the same&quot;</span>))
<a name="l00153"></a>00153     , points(initData(&amp;points, <span class="stringliteral">&quot;points&quot;</span>, <span class="stringliteral">&quot;defines the mapped points along the beam axis (in beam frame local coordinates)&quot;</span>))
<a name="l00154"></a>00154     , proximity(initData(&amp;proximity, 0.0, <span class="stringliteral">&quot;proximity&quot;</span>, <span class="stringliteral">&quot;if positive, the mapping is modified for the constraints to take into account the lever created by the proximity&quot;</span>))
<a name="l00155"></a>00155     , contactDuplicate(initData(&amp;contactDuplicate,false,<span class="stringliteral">&quot;contactDuplicate&quot;</span>,<span class="stringliteral">&quot;if true, this mapping is a copy of an input mapping and is used to gather contact points (ContinuousFrictionContact Response)&quot;</span>))
<a name="l00156"></a>00156     , nameOfInputMap(initData(&amp;nameOfInputMap,<span class="stringliteral">&quot;nameOfInputMap&quot;</span>, <span class="stringliteral">&quot;if contactDuplicate==true, it provides the name of the input mapping&quot;</span>))
<a name="l00157"></a>00157     , m_adaptativebeamInterpolation(initLink(<span class="stringliteral">&quot;interpolation&quot;</span>, <span class="stringliteral">&quot;Path to the Interpolation component on scene&quot;</span>))
<a name="l00158"></a>00158     , m_inputMapping(NULL)
<a name="l00159"></a>00159     , isSubMapping(_isSubMapping)
<a name="l00160"></a>00160     , isBarycentricMapping(false)
<a name="l00161"></a>00161     {
<a name="l00162"></a>00162                 <span class="keywordflow">if</span>(_interpolation)
<a name="l00163"></a>00163                         m_adaptativebeamInterpolation.set(_interpolation);
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165 
<a name="l00166"></a>00166         <span class="keywordtype">void</span> printIstrumentInfo()<span class="keyword">const</span>
<a name="l00167"></a>00167 <span class="keyword">        </span>{
<a name="l00168"></a>00168                 <span class="keywordflow">if</span> (isSubMapping)<span class="comment">//ctn_DEV</span>
<a name="l00169"></a>00169                 {
<a name="l00170"></a>00170                         std::cout&lt;&lt;<span class="stringliteral">&quot;Instrument Named &quot;</span>&lt;&lt;m_adaptativebeamInterpolation-&gt;getName()&lt;&lt;std::endl
<a name="l00171"></a>00171                                         &lt;&lt;<span class="stringliteral">&quot; MState1:&quot;</span>&lt;&lt;this-&gt;fromModel-&gt;getName()&lt;&lt; <span class="stringliteral">&quot;  size:&quot;</span>&lt;&lt;this-&gt;fromModel-&gt;getSize()&lt;&lt;std::endl
<a name="l00172"></a>00172                                         &lt;&lt;<span class="stringliteral">&quot; MState2:&quot;</span>&lt;&lt;this-&gt;toModel-&gt;getName()&lt;&lt; <span class="stringliteral">&quot;  size:&quot;</span>&lt;&lt;this-&gt;toModel-&gt;getSize()&lt;&lt;std::endl
<a name="l00173"></a>00173                                         &lt;&lt;<span class="stringliteral">&quot;idPointSubMap.&quot;</span>&lt;&lt;idPointSubMap.size()&lt;&lt;std::endl
<a name="l00174"></a>00174                                         &lt;&lt;<span class="stringliteral">&quot;pointBeamDistribution.&quot;</span>&lt;&lt;pointBeamDistribution.size()&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l00175"></a>00175                 }
<a name="l00176"></a>00176         }
<a name="l00177"></a>00177     <span class="keyword">virtual</span> ~AdaptiveBeamMapping(){}
<a name="l00178"></a>00178         
<a name="l00179"></a>00179         <span class="keywordtype">void</span> apply(<span class="keyword">const</span> core::MechanicalParams *mparams <span class="comment">/* PARAMS FIRST */</span>, Data&lt;VecCoord&gt;&amp; out, <span class="keyword">const</span> Data&lt;InVecCoord&gt;&amp; in);
<a name="l00180"></a>00180         
<a name="l00181"></a>00181         <span class="keywordtype">void</span> applyJ(<span class="keyword">const</span> core::MechanicalParams *mparams <span class="comment">/* PARAMS FIRST */</span>, Data&lt;VecDeriv&gt;&amp; out, <span class="keyword">const</span> Data&lt;InVecDeriv&gt;&amp; in);
<a name="l00182"></a>00182         
<a name="l00183"></a>00183         <span class="keywordtype">void</span> applyJT(<span class="keyword">const</span> core::MechanicalParams *mparams <span class="comment">/* PARAMS FIRST */</span>, Data&lt;InVecDeriv&gt;&amp; out, <span class="keyword">const</span> Data&lt;VecDeriv&gt;&amp; in);
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="keywordtype">void</span> applyJT(<span class="keyword">const</span> core::ConstraintParams *cparams <span class="comment">/* PARAMS FIRST */</span>, Data&lt;InMatrixDeriv&gt;&amp; out, <span class="keyword">const</span> Data&lt;OutMatrixDeriv&gt;&amp; in);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="keywordtype">int</span> addPoint ( <span class="keyword">const</span> Coord&amp; c, <span class="keywordtype">int</span> <span class="comment">/*indexFrom*/</span> )
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190 
<a name="l00191"></a>00191         <span class="keywordtype">int</span> i = points.getValue().size();
<a name="l00192"></a>00192         Vec3 test = c;
<a name="l00193"></a>00193 
<a name="l00194"></a>00194         points.beginEdit()-&gt;push_back(test);
<a name="l00195"></a>00195         points.endEdit();
<a name="l00196"></a>00196         <span class="keywordflow">return</span> i;
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199     <span class="keywordtype">void</span> setBarycentricMapping()
<a name="l00200"></a>00200     {
<a name="l00201"></a>00201         isBarycentricMapping=<span class="keyword">true</span>;
<a name="l00202"></a>00202         points.beginEdit()-&gt;clear();points.endEdit();
<a name="l00203"></a>00203     }
<a name="l00204"></a>00204         <span class="keywordtype">int</span> addBaryPoint(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; _beamId,<span class="keyword">const</span> Vec3&amp; _baryCoord,<span class="keywordtype">bool</span> <span class="comment">/*todo_straightline_spline_option*/</span>)
<a name="l00205"></a>00205         <span class="comment">//TODO add parameter label for different cases : unactive, linear, spline</span>
<a name="l00206"></a>00206         {
<a name="l00207"></a>00207                 <span class="comment">//attention, beamId here is not the edge Id, but the id of a vec_edge_list defined in BeamInterpolation</span>
<a name="l00208"></a>00208                 <span class="keywordtype">int</span> newpointId = pointBeamDistribution.size();
<a name="l00209"></a>00209                 pointBeamDistribution.resize(newpointId+1);
<a name="l00210"></a>00210                 pointBeamDistribution[newpointId].baryPoint=_baryCoord;
<a name="l00211"></a>00211                 pointBeamDistribution[newpointId].beamId=_beamId;
<a name="l00212"></a>00212                 <span class="keywordflow">return</span> newpointId;
<a name="l00213"></a>00213         }
<a name="l00214"></a>00214         <span class="comment">//void clear(){};////// CTN_DEV todo for ContactMapper</span>
<a name="l00215"></a>00215         <span class="comment">//clear the mapping in functions of size given</span>
<a name="l00216"></a>00216         <span class="keywordtype">void</span> clear(<span class="keywordtype">int</span> size)
<a name="l00217"></a>00217         {
<a name="l00218"></a>00218                 this-&gt;clearidPointSubMap();
<a name="l00219"></a>00219                 pointBeamDistribution.clear();
<a name="l00220"></a>00220                 <span class="keywordflow">if</span> ( size&gt;0 &amp;&amp; !isSubMapping)
<a name="l00221"></a>00221                 {
<a name="l00222"></a>00222                         pointBeamDistribution.reserve ( size );
<a name="l00223"></a>00223                 points.beginEdit()-&gt;reserve ( size ); points.endEdit();
<a name="l00224"></a>00224                         this-&gt;getMechTo()[0]-&gt;resize(size);
<a name="l00225"></a>00225                 }
<a name="l00226"></a>00226                 <span class="keywordflow">else</span>
<a name="l00227"></a>00227                 <span class="comment">//case where this clear is call by a Multimapping, all component will be clear to null size</span>
<a name="l00228"></a>00228                 {
<a name="l00229"></a>00229                 points.beginEdit()-&gt;resize(0); points.endEdit();
<a name="l00230"></a>00230                         this-&gt;getMechTo()[0]-&gt;resize(0);
<a name="l00231"></a>00231                 }
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234     <span class="keywordtype">void</span> computeIdxAndBaryCoordsForAbs(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;b, Real &amp;x_bary, <span class="keyword">const</span> Real &amp;x_abs );
<a name="l00235"></a>00235 
<a name="l00236"></a>00236     <span class="keywordtype">void</span> init();            <span class="comment">// get the interpolation</span>
<a name="l00237"></a>00237     <span class="keywordtype">void</span> bwdInit();        <span class="comment">// get the points</span>
<a name="l00238"></a>00238     <span class="keywordtype">void</span> reset(){init();  computeDistribution();}
<a name="l00239"></a>00239     <span class="keywordtype">void</span> reinit(){init(); computeDistribution();}
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         <span class="keywordtype">void</span> draw(<span class="keyword">const</span> core::visual::VisualParams*);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="keywordtype">void</span> beginAddContactPoint();
<a name="l00244"></a>00244 
<a name="l00245"></a>00245     <span class="keywordtype">void</span> clearidPointSubMap(){idPointSubMap.clear();}
<a name="l00246"></a>00246     <span class="keywordtype">void</span> addidPointSubMap(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _id){idPointSubMap.push_back(_id);}
<a name="l00247"></a>00247     <span class="keywordtype">void</span> setuseCurvAbs(<span class="keywordtype">bool</span> _value){useCurvAbs.setValue(_value);}
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">protected</span>:
<a name="l00251"></a>00251 
<a name="l00252"></a>00252     <span class="keywordtype">void</span> applyJonPoint(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, SpatialVector&amp; VNode0input, SpatialVector&amp; VNode1input, Deriv&amp; vOutput, <span class="keyword">const</span> InVecCoord&amp; x);
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     <span class="keywordtype">void</span> applyJTonPoint(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> Deriv&amp; finput, SpatialVector&amp; FNode0output, SpatialVector&amp; FNode1output, <span class="keyword">const</span> InVecCoord&amp; x);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256     <span class="keywordtype">void</span> computeJacobianOnPoint(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keyword">typename</span> In::VecCoord&amp; x);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="keywordtype">void</span> computeDistribution();
<a name="l00259"></a>00259 
<a name="l00260"></a>00260     sofa::core::topology::TopologyContainer* _topology;
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     <span class="keywordtype">bool</span> x_buf_used;
<a name="l00264"></a>00264     <span class="keyword">typename</span> In::VecCoord x_buf;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     sofa::helper::vector&lt; PosPointDefinition &gt; pointBeamDistribution;
<a name="l00267"></a>00267     <span class="comment">// for continuous_friction_contact:</span>
<a name="l00268"></a>00268     AdaptiveBeamMapping&lt;TIn, TOut&gt; *m_inputMapping;
<a name="l00269"></a>00269     sofa::helper::vector&lt;unsigned int&gt; idPointSubMap;
<a name="l00270"></a>00270     <span class="keywordtype">bool</span> isSubMapping;
<a name="l00271"></a>00271     <span class="keywordtype">bool</span> isBarycentricMapping;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="keyword">public</span> :
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 
<a name="l00276"></a>00276 };
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 } <span class="comment">// namespace mapping</span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 } <span class="comment">// namespace component</span>
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 } <span class="comment">// namespace sofa</span>
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="preprocessor">#endif  </span><span class="comment">/* SOFA_COMPONENT_MAPPING_ADAPTIVEBEAMMAPPING_H */</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>AdaptiveBeamMapping.h</b>      </li>

    <li class="footer">Generated on Thu Jul 19 2012 16:57:11 for BeamAdapter by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
